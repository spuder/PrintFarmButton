name: Build ESPHome Firmware

on:
  push:
    tags:
      - '[0-9]+.[0-9]+.[0-9]+*'
  workflow_dispatch:

permissions:
  contents: write
  actions: read
  checks: write

jobs:
  build:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        include:
          - target: esp32s3-zero
            build_name: pfb-s3-zero-esp32s3
          - target: esp32s3-supermini
            build_name: pfb-s3-mini-esp32s3
          - target: esp32c3-zero
            build_name: pfb-c3-zero-esp32c3
          - target: esp32c3-supermini
            build_name: pfb-c3-mini-esp32c3
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Create empty secrets file
        run: |
          touch firmware/esphome/secrets.yaml || true
      
      - name: Setup yq
        uses: vegardit/gha-setup-yq@v1

      - name: Set git sha
        run: |
          SUMMARY=$(git log -1 --pretty=%B)
          SUMMARY="${SUMMARY//'%'/'%25'}"
          SUMMARY="${SUMMARY//$'\n'/'%0A'}"
          SUMMARY="${SUMMARY//$'\r'/'%0D'}"
          echo "RELEASE_SUMMARY=$SUMMARY" >> $GITHUB_ENV

      - name: Modify version.yaml
        run: |
          yq -i '.substitutions.version = "${{ github.ref_name }}"' firmware/esphome/conf.d/version.yaml
          cat firmware/esphome/conf.d/version.yaml

      - name: Build ESP32-S3 Zero firmware
        uses: esphome/build-action@v6
        with:
          yaml-file: firmware/esphome/esp32s3-zero.yaml
          complete-manifest: false
        if: matrix.target == 'esp32s3-zero'

      - name: Build ESP32-S3 SuperMini firmware
        uses: esphome/build-action@v6
        with:
          yaml-file: firmware/esphome/esp32s3-supermini.yaml
          complete-manifest: false
        if: matrix.target == 'esp32s3-supermini'

      - name: Build ESP32-C3 Zero firmware
        uses: esphome/build-action@v6
        with:
          yaml-file: firmware/esphome/esp32c3-zero.yaml
          complete-manifest: false
        if: matrix.target == 'esp32c3-zero'

      - name: Build ESP32-C3 SuperMini firmware
        uses: esphome/build-action@v6
        with:
          yaml-file: firmware/esphome/esp32c3-supermini.yaml
          complete-manifest: false
        if: matrix.target == 'esp32c3-supermini'

      - name: List build output
        run: |
          ls -la
          ls ${{ matrix.build_name }}/* || true

      - name: Generate md5 checksum
        run: |
          ls -la ${{ matrix.build_name }}
          for file in ${{ matrix.build_name }}/*.bin; do
            md5sum "$file" | awk '{print $1}' > "${file}.md5"
            md5_length=$(wc -c < "${file}.md5")
            if [ "$md5_length" -ne 33 ]; then
              echo "MD5 generation failed for $file (length: $md5_length)"
              exit 1
            fi
          done
          ls -la ${{ matrix.build_name }}

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.build_name }}
          path: ${{ matrix.build_name }}/**/*
          retention-days: 5
          if-no-files-found: error

  combine-and-deploy:
    needs: build
    runs-on: ubuntu-latest
    if: startsWith(github.ref, 'refs/tags/')
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: downloaded-artifacts

      - name: List artifacts
        run: |
          echo "Downloaded artifacts structure:"
          ls -la downloaded-artifacts/
          echo ""
          echo "Contents of each artifact:"
          for dir in downloaded-artifacts/*/; do
            if [ -d "$dir" ]; then
              echo "=== Contents of $dir ==="
              ls -la "$dir"
              echo ""
            fi
          done

      - name: Prepare output directory
        run: |
          mkdir -p firmware/output
          for build_name in pfb-s3-mini-esp32s3 pfb-s3-zero-esp32s3 pfb-c3-mini-esp32c3 pfb-c3-zero-esp32c3; do
            cp downloaded-artifacts/$build_name/*.bin firmware/output/ || true
            cp downloaded-artifacts/$build_name/*.md5 firmware/output/ || true
          done

      - name: Get version from git tag or branch
        id: get_version
        run: |
          # Prefer tags that do NOT start with 'v' if both exist on the same commit
          VERSION=$(git tag --points-at HEAD | grep -E '^[0-9]+\.[0-9]+\.[0-9]+' | head -n1)
          if [ -z "$VERSION" ]; then
            VERSION=${GITHUB_REF_NAME}
          fi
          echo "VERSION=$VERSION" >> $GITHUB_ENV

      - name: Create ESP Web Tools manifest files
        run: |
          # Create the main combined manifest for ESP Web Tools
          jq -n --arg version "$VERSION" '{
            name: "PrintFarmButton",
            version: $version,
            builds: [],
            new_install_prompt_erase: true
          }' > firmware/output/manifest.json

          # Create separate manifests for OTA updates
          jq -n --arg version "$VERSION" '{
            name: "PrintFarmButton SuperMini",
            version: $version,
            builds: [],
            new_install_prompt_erase: true
          }' > firmware/output/manifest-supermini.json

          jq -n --arg version "$VERSION" '{
            name: "PrintFarmButton Zero",
            version: $version,
            builds: [],
            new_install_prompt_erase: true
          }' > firmware/output/manifest-zero.json

          echo "Looking for build artifacts..."
          for build_name in pfb-s3-mini-esp32s3 pfb-s3-zero-esp32s3 pfb-c3-mini-esp32c3 pfb-c3-zero-esp32c3; do
            echo "Processing build: $build_name"
            
            # Check if the artifact directory exists
            if [ -d "downloaded-artifacts/$build_name" ]; then
              echo "Found artifact directory: downloaded-artifacts/$build_name"
              ls -la "downloaded-artifacts/$build_name"
              
              # Determine project name and target manifest based on build name
              project_name=""
              target_manifest=""
              if [[ "$build_name" == *"mini"* ]]; then
                project_name="spuder.printfarmbutton-mini"
                target_manifest="firmware/output/manifest-supermini.json"
              elif [[ "$build_name" == *"zero"* ]]; then
                project_name="spuder.printfarmbutton-zero"
                target_manifest="firmware/output/manifest-zero.json"
              else
                echo "Error: Cannot determine project name for build: $build_name"
                exit 1
              fi
              
              # Check if manifest.json exists
              if [ -f "downloaded-artifacts/$build_name/manifest.json" ]; then
                echo "Found ESPHome-generated manifest.json for $build_name"
                echo "Manifest contents:"
                cat "downloaded-artifacts/$build_name/manifest.json"
                
                # Process the manifest
                manifest_content=$(cat "downloaded-artifacts/$build_name/manifest.json")
                
                # Add project field to the manifest entry
                updated_manifest=$(echo "$manifest_content" | jq --arg project "$project_name" '. + {"project": $project}')
                
                # Add the build entry to both the main manifest and target manifest
                jq --argjson new_build "$updated_manifest" '.builds += [$new_build]' firmware/output/manifest.json > temp.json && mv temp.json firmware/output/manifest.json
                jq --argjson new_build "$updated_manifest" '.builds += [$new_build]' "$target_manifest" > temp.json && mv temp.json "$target_manifest"
                
                echo "Successfully added $build_name to manifests using ESPHome manifest"
              else
                echo "No ESPHome manifest found for $build_name, creating fallback entry..."
                
                # Create fallback manifest entry
                chip_family="ESP32"
                if [[ "$build_name" == *"s3"* ]]; then
                  chip_family="ESP32-S3"
                elif [[ "$build_name" == *"c3"* ]]; then
                  chip_family="ESP32-C3"
                fi
                
                # Look for binary files
                factory_bin=""
                ota_bin=""
                
                # Try different naming patterns
                for pattern in "${build_name}.factory.bin" "*.factory.bin"; do
                  if [ -f "downloaded-artifacts/$build_name"/$pattern ]; then
                    factory_bin=$(basename "downloaded-artifacts/$build_name"/$pattern)
                    break
                  fi
                done
                
                for pattern in "${build_name}.ota.bin" "*.ota.bin"; do
                  if [ -f "downloaded-artifacts/$build_name"/$pattern ]; then
                    ota_bin=$(basename "downloaded-artifacts/$build_name"/$pattern)
                    break
                  fi
                done
                
                # Create manifest entry
                if [ -n "$factory_bin" ] && [ -n "$ota_bin" ]; then
                  echo "Creating full manifest entry with factory and OTA binaries"
                  manifest_entry=$(jq -n --arg chip "$chip_family" --arg project "$project_name" --arg factory_path "$factory_bin" --arg ota_path "$ota_bin" '{
                    "chipFamily": $chip, 
                    "project": $project, 
                    "parts": [{"path": $factory_path, "offset": 0}],
                    "ota": {"path": $ota_path}
                  }')
                elif [ -n "$factory_bin" ]; then
                  echo "Creating manifest entry with factory binary only"
                  manifest_entry=$(jq -n --arg chip "$chip_family" --arg project "$project_name" --arg factory_path "$factory_bin" '{
                    "chipFamily": $chip, 
                    "project": $project, 
                    "parts": [{"path": $factory_path, "offset": 0}]
                  }')
                else
                  echo "Error: No binary files found for $build_name"
                  echo "Available files:"
                  ls -la "downloaded-artifacts/$build_name/"
                  exit 1
                fi
                
                # Add to both main manifest and target manifest
                jq --argjson new_build "$manifest_entry" '.builds += [$new_build]' firmware/output/manifest.json > temp.json && mv temp.json firmware/output/manifest.json
                jq --argjson new_build "$manifest_entry" '.builds += [$new_build]' "$target_manifest" > temp.json && mv temp.json "$target_manifest"
                
                echo "Successfully created fallback manifest entry for $build_name"
              fi
            else
              echo "Error: Artifact directory not found: downloaded-artifacts/$build_name"
              echo "Available artifacts:"
              ls -la downloaded-artifacts/
              exit 1
            fi
          done

          echo "Final main manifest:"
          jq '.' firmware/output/manifest.json
          echo ""
          echo "Final supermini manifest:"
          jq '.' firmware/output/manifest-supermini.json
          echo ""
          echo "Final zero manifest:"
          jq '.' firmware/output/manifest-zero.json

      - name: List files in output directory
        run: |
          echo "Contents of firmware/output:"
          ls -lh firmware/output/

      - name: Commit and push build artifacts
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          git stash push -m "Stash before switching to main"
          git checkout main
          git pull origin main
          git stash apply || true
          git add firmware/output/
          git add firmware/esphome/conf.d/version.yaml
          if git diff --staged --quiet; then
            echo "No changes to commit"
          else
            git commit -m "Update firmware build and version.yaml [skip ci]"
            git push origin main
          fi