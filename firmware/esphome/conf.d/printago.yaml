# Global variables to store printer status (not persisted across reboots)
globals:
# Values returned by API
- id: printer_confirmed_ready
  type: bool
  restore_value: false
  initial_value: 'false'

- id: printer_is_available
  type: bool
  restore_value: false
  initial_value: 'false'

- id: printer_is_online
  type: bool
  restore_value: false
  initial_value: 'false'

# Values returned by MQTT
- id: state_string
  type: std::string
  restore_value: false
  initial_value: ''

# Sensors to display global values in web UI
binary_sensor:
- platform: template
  name: "Printer Confirmed Ready"
  id: printer_confirmed_ready_sensor
  lambda: |-
    return id(printer_confirmed_ready_sensor).state;
  icon: "mdi:printer-check"
  on_state:
    then:
    - script.execute: update_led_color
  internal: false

- platform: template
  name: "Printer Is Available"
  id: printer_is_available_sensor
  lambda: |-
    return id(printer_is_available_sensor).state;
  icon: "mdi:printer"
  on_state:
    then:
    - script.execute: update_led_color
  internal: false

- platform: template
  name: "Printer Is Online"
  id: printer_is_online_sensor
  lambda: |-
    return id(printer_is_online_sensor).state;
  icon: "mdi:lan-connect"
  on_state:
    then:
    - script.execute: update_led_color
  internal: false

text_sensor:

- platform: template
  name: "Combined Printer Status"
  id: combined_status_sensor
  lambda: |-
    std::string status = "API: ";
    status += id(printer_confirmed_ready) ? "Ready" : "Not Ready";
    status += ", ";
    status += id(printer_is_available) ? "Available" : "Unavailable";
    status += ", ";
    status += id(printer_is_online) ? "Online" : "Offline";
    if (!id(state_string).empty()) {
      status += " | MQTT State: " + id(state_string);
    }
    return status;
  icon: "mdi:information"
  update_interval: 5s
  state_topic:
  web_server:
    sorting_group_id: diagnostic

script:
- id: check_printago_status
  mode: queued
  then:
  - if:
      condition:
        and:
        - lambda: 'return !id(printer_id).state.empty();'
        - lambda: 'return !id(api_key_text).state.empty();'
        - lambda: 'return !id(username_text).state.empty();'
      then:
      - http_request.get:
          url: !lambda |-
            return "https://api.printago.io/v1/printers/" + id(printer_id).state;
          request_headers:
            authorization: !lambda |-
              return ("ApiKey " + id(api_key_text).state).c_str();
            x-printago-storeid: !lambda |-
              return id(username_text).state.c_str();
          capture_response: true
          max_response_buffer_size: 2048
          on_response:
            then:
            - lambda: |-
                ESP_LOGI("printago", "HTTP Response code: %d", response->status_code);
                ESP_LOGI("printago", "Response body length: %d bytes", body.length());
                if (response->status_code == 200) {
                  DynamicJsonDocument doc(2048);
                  DeserializationError error = deserializeJson(doc, body);
                  if (error) {
                    ESP_LOGW("printago", "Failed to parse JSON: %s", error.c_str());
                    return;
                  }
                  bool confirmed_ready = doc["confirmedReady"] | false;
                  bool is_available = doc["isAvailable"] | false;
                  bool is_online = doc["isOnline"] | false;
                  std::string state = doc["metadata"]["print_status"] | "";
                  id(printer_confirmed_ready) = confirmed_ready;
                  id(printer_is_available) = is_available;
                  id(printer_is_online) = is_online;
                  id(state_string) = state;
                  ESP_LOGI("printago", "Updated state_string: %s", state.c_str());
                } else {
                  ESP_LOGW("printago", "HTTP error %d", response->status_code);
                }
      else:
      - lambda: |-
          ESP_LOGW("printago", "Not running check_printago_status: printer_id, api_key_text, or username_text is missing");

- id: clear_printago_status
  mode: queued
  then:
  - lambda: |-
      // Clear all global printer status variables
      id(printer_confirmed_ready) = false;
      id(printer_is_available) = false;
      id(printer_is_online) = false;

      ESP_LOGI("printago", "Cleared all printer status globals - all set to false");

- id: update_led_color
  mode: queued
  then:
  - if:
      condition:
        not:
        - lambda: 'return id(printer_is_online);'
      then:
      - light.turn_on:
          id: openqueue_rgb
          red: 1.0
          green: 1.0
          blue: 1.0
      else:
      - if:
          condition:
            and:
            - lambda: 'return id(printer_is_online);'
            - lambda: 'return id(printer_confirmed_ready);'
            - lambda: 'return id(printer_is_available);'
          then:
          # Blue (Ready)
          - light.turn_on:
              id: openqueue_rgb
              red: 0.0
              green: 0.0
              blue: 1.0
          else:
          - if:
              condition:
                and:
                - lambda: 'return id(printer_is_online);'
                - lambda: 'return !id(printer_confirmed_ready);'
                - lambda: 'return id(printer_is_available);'
              then:
              - light.turn_on:
                  id: openqueue_rgb
                  red: 0.5
                  green: 0.0
                  blue: 0.5
              else:
              - if:
                  condition:
                    and:
                    - lambda: 'return id(printer_is_online);'
                    - lambda: 'return !id(printer_is_available);'
                    - lambda: 'return !id(printer_confirmed_ready);'
                  then:
                  # Green (Busy)
                  - light.turn_on:
                      id: openqueue_rgb
                      red: 0.0
                      green: 1.0
                      blue: 0.0
                  else:
                  # Fallback/default
                  - light.turn_on:
                      id: openqueue_rgb
                      red: 1.0
                      green: 1.0
                      blue: 1.0

text:
- platform: template
  name: "Api Key"
  id: api_key_text
  mode: password
  restore_value: true
  optimistic: true
  state_topic:
  web_server:
    sorting_group_id: printago

- platform: template
  name: "Username"
  id: username_text
  mode: text
  restore_value: true
  optimistic: true
  state_topic:
  web_server:
    sorting_group_id: printago
  on_value:
    then:
    - lambda: |-
        ESP_LOGI("mqtt", "Username changed to: %s", x.c_str());

        // Generate client_id with format: apiclient_<username>_<random_suffix>
        std::string client_id = "apiclient_" + x + "_" + std::to_string(random_uint32());
        ESP_LOGI("mqtt", "Setting client_id to: %s", client_id.c_str());

        // Set both username and client_id
        id(mqtt_client_id).set_username(x);
        id(mqtt_client_id).set_client_id(client_id.c_str());

        // Check if we should connect/reconnect to MQTT
        if (!x.empty() && !id(printer_id).state.empty()) {
          ESP_LOGI("mqtt", "Both username and printer ID are set, connecting to MQTT");
          id(clear_printago_status).execute();
          id(check_printago_status).execute();
          id(mqtt_client_id).enable();
        } else {
          ESP_LOGI("mqtt", "Username or printer ID missing, disconnecting MQTT");
          id(mqtt_client_id).disable();
        }

- platform: template
  id: printer_id_previous
  mode: text
  restore_value: false
  optimistic: true
  state_topic:
  internal: true

- platform: template
  name: "Printer ID"
  id: printer_id
  mode: text
  restore_value: true
  optimistic: true
  state_topic:
  web_server:
    sorting_group_id: printago
  on_value:
    then:
    - lambda: |-
        std::string previous_printer_id = id(printer_id_previous).state;
        std::string new_printer_id = x;

        ESP_LOGI("mqtt", "Printer ID changing from '%s' to '%s'", previous_printer_id.c_str(), new_printer_id.c_str());

        // Check if we should connect/reconnect to MQTT
        if (!new_printer_id.empty() && !id(username_text).state.empty()) {
          ESP_LOGI("mqtt", "Both username and printer ID are set, enabling MQTT");
          id(clear_printago_status).execute();
          id(check_printago_status).execute();
          id(mqtt_client_id).enable();
        } else {
          ESP_LOGI("mqtt", "Username or printer ID missing, disabling MQTT");
          id(clear_printago_status).execute();
          id(mqtt_client_id).disable();
          return;
        }

        // Unsubscribe from previous topic first
        if (!previous_printer_id.empty() && !id(username_text).state.empty()) {
          std::string old_topic = "stores/" + id(username_text).state + "/printer-stats/" + previous_printer_id;
          ESP_LOGI("mqtt", "Unsubscribing from previous topic: %s", old_topic.c_str());
          id(mqtt_client_id).unsubscribe(old_topic);
        }

        // Store the new value as the "previous" for next time
        id(printer_id_previous).publish_state(new_printer_id);

        // Subscribe to new topic only if new printer ID is not empty
        if (!new_printer_id.empty() && !id(username_text).state.empty()) {
          std::string topic = "stores/" + id(username_text).state + "/printer-stats/" + new_printer_id;
          ESP_LOGI("mqtt", "Subscribing to new topic: %s", topic.c_str());
          
          id(mqtt_client_id).subscribe_json(topic, [=](const std::string &topic, JsonObject root) {
            ESP_LOGI("mqtt", "Received JSON on topic %s", topic.c_str());
            
            bool is_online = root.containsKey("isOnline") ? root["isOnline"] : false;
            std::string state = root.containsKey("state") ? root["state"].as<std::string>() : "";
            bool is_available = root.containsKey("isAvailable") ? root["isAvailable"] : false;
            ESP_LOGI("mqtt", "Parsed isOnline: %s, state: %s, isAvailable: %s", is_online ? "true" : "false", state.c_str(), is_available ? "true" : "false");
            
            // Store a summary instead of full JSON to avoid storage issues
            std::string summary = "Online:" + std::string(is_online ? "true" : "false") + 
                                 " State:" + state + 
                                 " Available:" + std::string(is_available ? "true" : "false");
            id(last_mqtt_message).publish_state(summary);

          });
        }

button:
- platform: template
  name: "Check Printago Status"
  id: check_printago_status_button
  icon: "mdi:cloud-refresh"
  on_press:
  - script.execute: check_printago_status
  web_server:
    sorting_group_id: diagnostic
