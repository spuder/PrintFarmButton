binary_sensor:
- platform: template
  name: "Printer Confirmed Ready"
  id: printer_confirmed_ready_sensor
  lambda: |-
    return id(printer_confirmed_ready_sensor).state;
  icon: "mdi:printer-check"
  on_state:
    then:
    - script.execute: update_led_color
  internal: false

- platform: template
  name: "Printer Is Available"
  id: printer_is_available_sensor
  lambda: |-
    return id(printer_is_available_sensor).state;
  icon: "mdi:printer"
  on_state:
    then:
    - script.execute: update_led_color
  internal: false

- platform: template
  name: "Printer Is Online"
  id: printer_is_online_sensor
  lambda: |-
    return id(printer_is_online_sensor).state;
  icon: "mdi:lan-connect"
  on_state:
    then:
    - script.execute: update_led_color
  internal: false

- platform: template
  name: "Printer Has Error"
  id: printer_has_error_sensor
  lambda: |-
    return id(printer_has_error_sensor).state;
  icon: "mdi:printer-alert"
  on_state:
    then:
    - script.execute: update_led_color
  internal: false

- platform: template
  name: "Printer Has Warning"
  id: printer_has_warning_sensor
  lambda: |-
    return id(printer_has_warning_sensor).state;
  icon: "mdi:printer-warning"
  on_state:
    then:
    - script.execute: update_led_color
  internal: false

- platform: template
  name: "Is Downloading"
  id: is_downloading
  lambda: |-
    return id(is_downloading).state;
  icon: "mdi:download"
  internal: false
  on_state:
    then:
    - script.execute: update_led_color

script:
- id: check_printago_status
  mode: queued
  then:
  - if:
      condition:
        and:
        - lambda: 'return !id(printer_id).state.empty();'
        - lambda: 'return !id(api_key_text).state.empty();'
        - lambda: 'return !id(username_text).state.empty();'
        - lambda: 'return !id(mqtt_endpoint_text).state.empty();'
      then:
      - http_request.get:
          url: !lambda |-
            return "https://api.printago.io/v1/printers/" + id(printer_id).state;
          request_headers:
            authorization: !lambda |-
              static std::string key;
              std::string raw_key = id(api_key_text).state;
              raw_key.erase(std::remove_if(raw_key.begin(), raw_key.end(), ::isspace), raw_key.end());
              key = "ApiKey " + raw_key;
              return key.c_str();
            x-printago-storeid: !lambda |-
              static std::string store;
              std::string raw_store = id(username_text).state;
              raw_store.erase(std::remove_if(raw_store.begin(), raw_store.end(), ::isspace), raw_store.end());
              store = raw_store;
              return store.c_str();
          capture_response: true
          max_response_buffer_size: 2048
          on_response:
            then:
            - lambda: |-
                ESP_LOGI("printago", "HTTP Response code: %d", response->status_code);
                ESP_LOGI("printago", "Response body length: %d bytes", body.length());
                if (response->status_code == 200) {
                  DynamicJsonDocument doc(2048);
                  DeserializationError error = deserializeJson(doc, body);
                  if (error) {
                    ESP_LOGW("printago", "Failed to parse JSON: %s", error.c_str());
                    return;
                  }
                  bool confirmed_ready = doc["confirmedReady"] | false;
                  bool is_available = doc["isAvailable"] | false;
                  bool is_online = doc["isOnline"] | false;
                  
                  // Extract and set printer name from metadata if available
                  if (doc.containsKey("metadata") && doc["metadata"].containsKey("name")) {
                    const char* name = doc["metadata"]["name"].as<const char*>();
                    if (name != nullptr) {
                      ESP_LOGI("printago", "Set printer name to: %s", name);
                      id(printer_name).publish_state(name);
                    }
                  }
                  
                  id(printer_confirmed_ready_sensor).publish_state(confirmed_ready);
                  id(printer_is_available_sensor).publish_state(is_available);
                  id(printer_is_online_sensor).publish_state(is_online);
                } else {
                  ESP_LOGW("printago", "HTTP error %d", response->status_code);
                }
      else:
      - lambda: |-
          ESP_LOGW("printago", "Not running check_printago_status: printer_id, api_key_text, or username_text is missing");

- id: clear_printago_status
  mode: queued
  then:
  - lambda: |-
      // Clear all global printer status variables
      id(printer_confirmed_ready_sensor).publish_state(false);
      id(printer_is_available_sensor).publish_state(false);
      id(printer_is_online_sensor).publish_state(false);
      id(printer_name).publish_state("");  // Clear printer name

      ESP_LOGI("printago", "Cleared all printer status globals - all set to false");

- id: update_led_color
  mode: queued
  then:
  - if:
      condition:
        not:
        - lambda: 'return id(printer_is_online_sensor).state;'
      then: # LED white on offline

      # - light.turn_on:
      #     id: printfarmbutton_rgb
      #     red: 1.0
      #     green: 1.0
      #     blue: 1.0
      #     effect: none
      #     brightness: 90%
      else:
      - if:
          condition:
            or:
            - lambda: 'return id(printer_has_error_sensor).state;'
            - lambda: 'return id(printer_has_warning_sensor).state;'
          then:
          - light.turn_on:
              id: printfarmbutton_rgb
              red: 1.0
              green: 0.0
              blue: 0.0
              effect: none
              brightness: 90%
          else:
          - if:
              condition:
                and:
                - lambda: 'return id(is_downloading).state;'
              then:
              - light.turn_on:
                  id: printfarmbutton_rgb
                  red: 0.0
                  green: 1.0
                  blue: 0.0
                  effect: Left2Right
                  brightness: 90%
              else:
              - if:
                  condition:
                    and:
                    - lambda: 'return id(printer_confirmed_ready_sensor).state;'
                    - lambda: 'return id(printer_is_available_sensor).state;'
                  then:
                  # Blue (Ready)
                  - light.turn_on:
                      id: printfarmbutton_rgb
                      red: 0.0
                      green: 0.0
                      blue: 1.0
                      effect: none
                      brightness: 90%
                  else:
                  - if:
                      condition:
                        and:
                        - lambda: 'return !id(printer_confirmed_ready_sensor).state;'
                        - lambda: 'return id(printer_is_available_sensor).state;'
                      then:
                      # Magenta (Set Ready)
                      - light.turn_on:
                          id: printfarmbutton_rgb
                          red: 0.9
                          green: 0.0
                          blue: 0.7
                          effect: Pulse
                          brightness: 90%
                      else:
                      - if:
                          condition:
                            and:
                            - lambda: 'return !id(printer_is_available_sensor).state;'
                            - lambda: 'return !id(printer_confirmed_ready_sensor).state;'
                          then:
                          # Green (Busy)
                          - light.turn_on:
                              id: printfarmbutton_rgb
                              red: 0.0
                              green: 1.0
                              blue: 0.0
                              effect: none
                              brightness: 90%
                          else:
                          # Fallback/default
                          - light.turn_on:
                              id: printfarmbutton_rgb
                              red: 1.0
                              green: 1.0
                              blue: 1.0
                              effect: none
                              brightness: 90%
- id: mark_printer_ready
  mode: queued
  then:
  - if:
      condition:
        and:
        - lambda: 'return !id(printer_id).state.empty();'
        - lambda: 'return !id(api_key_text).state.empty();'
        - lambda: 'return !id(username_text).state.empty();'
        - lambda: 'return !id(mqtt_endpoint_text).state.empty();'
        - lambda: 'return !id(mqtt_port_text).state.empty();'
        - lambda: 'return !id(printer_confirmed_ready_sensor).state;'
        - lambda: 'return id(printer_is_available_sensor).state;'
      then:
      - http_request.send:
          method: PATCH
          url: !lambda |-
            return "https://api.printago.io/v1/printers/confirm-ready";
          request_headers:
            authorization: !lambda |-
              return ("ApiKey " + id(api_key_text).state).c_str();
            x-printago-storeid: !lambda |-
              return id(username_text).state.c_str();
            content-type: application/json
          body: !lambda |-
            return std::string("{\"ready\": true, \"ids\": [\"") + id(printer_id).state + "\"]}";
          capture_response: true
          max_response_buffer_size: 2048
          on_response:
            then:
            - lambda: |-
                ESP_LOGI("printago", "Mark printer ready response: %d", response->status_code);
                if (response->status_code == 200) {
                  ESP_LOGI("printago", "Printer marked as ready");
                } else {
                  ESP_LOGW("printago", "Failed to mark printer as ready");
                }
      else:
      - lambda: |-
          ESP_LOGW("printago", "Not running mark_printer_ready: printer is not in the correct state (must be available and not already confirmed ready), or required fields are missing");

- id: fetch_printago_printers
  mode: queued
  then:
  - if:
      condition:
        and:
        - lambda: 'return !id(api_key_text).state.empty();'
        - lambda: 'return !id(username_text).state.empty();'
      then:
      - http_request.get:
          url: "https://api.printago.io/v1/printers"
          request_headers:
            authorization: !lambda |-
              static std::string key;
              std::string raw_key = id(api_key_text).state;
              raw_key.erase(std::remove_if(raw_key.begin(), raw_key.end(), ::isspace), raw_key.end());
              key = "ApiKey " + raw_key;
              return key.c_str();
            x-printago-storeid: !lambda |-
              static std::string store;
              std::string raw_store = id(username_text).state;
              raw_store.erase(std::remove_if(raw_store.begin(), raw_store.end(), ::isspace), raw_store.end());
              store = raw_store;
              return store.c_str();
          capture_response: true
          max_response_buffer_size: 8192
          on_response:
            then:
            - lambda: |-
                ESP_LOGI("printago", "Fetch printers response: %d", response->status_code);
                if (response->status_code == 200) {
                  ESP_LOGI("printago", "Response body length: %d bytes", body.length());
                  DynamicJsonDocument doc(8192);
                  DeserializationError error = deserializeJson(doc, body);
                  
                  if (!error && doc.is<JsonArray>()) {
                    JsonArray printers = doc.as<JsonArray>();
                    ESP_LOGI("printago", "Found %d printers", printers.size());
                    
                    for (JsonVariant printer : printers) {
                      if (printer.is<JsonObject>()) {
                        JsonObject printerObj = printer.as<JsonObject>();
                        const char* id = printerObj["id"] | "unknown";
                        const char* name = printerObj["name"] | "unnamed";
                        ESP_LOGI("printago", "Printer: %s (%s)", name, id);
                      }
                    }
                  } else {
                    ESP_LOGW("printago", "Failed to parse JSON response");
                  }
                } else {
                  ESP_LOGW("printago", "HTTP error %d", response->status_code);
                }
      else:
      - lambda: |-
          ESP_LOGW("printago", "Not running fetch_printago_printers: api_key_text or username_text is missing");

text_sensor:
- platform: template
  name: "Printer Name"
  id: printer_name
  icon: "mdi:printer-3d"
  state_topic:
  web_server:
    sorting_group_id: printago
    sorting_weight: 2

- platform: template
  name: "MQTT Client ID"
  id: mqtt_client_id_stored
  state_topic:
  internal: false
  web_server:
    sorting_group_id: printago
    sorting_weight: 9
  icon: "mdi:identifier"
  lambda: |-
    std::string username = id(username_text).state;

    // Clean username
    username.erase(std::remove_if(username.begin(), username.end(), ::isspace), username.end());

    if (!username.empty()) {
      // Generate MQTT client_id from username and last 6 digits of MAC address
      std::string mac = get_mac_address();
      mac.erase(std::remove(mac.begin(), mac.end(), ':'), mac.end());
      
      // Get last 6 digits of MAC address
      std::string mac_suffix = mac.length() >= 6 ? mac.substr(mac.length() - 6) : mac;
      
      std::string client_id = "apiclient_" + username + "_" + mac_suffix;
      
      // Set MQTT credentials
      id(mqtt_client_id).set_username(username.c_str());
      id(mqtt_client_id).set_client_id(client_id.c_str());
      
      ESP_LOGI("mqtt", "Generated client_id: %s", client_id.c_str());
      ESP_LOGI("mqtt", "MQTT Credentials Set - Username: %s, Client ID: %s", username.c_str(), client_id.c_str());
      ESP_LOGI("mqtt", "Current MQTT Config - Broker: %s, Port: %s", 
               id(mqtt_endpoint_text).state.c_str(), 
               id(mqtt_port_text).state.c_str());
      return client_id;
    } else {
      ESP_LOGW("mqtt", "Username is empty, cannot generate client_id");
      return std::string(""); // Return empty string if no username
    }
  on_value:
    then:
    - lambda: |-
        ESP_LOGI("mqtt", "Client ID value updated to: %s", x.c_str());

text:
- platform: template
  name: "Api Key" #This name is the key for the rest api, do not change
  id: api_key_text
  mode: password
  restore_value: true
  optimistic: true
  state_topic:
  web_server:
    sorting_group_id: printago
    sorting_weight: 5
  icon: "mdi:key"
  on_value:
    then:
    - lambda: |-
        ESP_LOGI("mqtt", "API Key changed, updating MQTT client ID");
        // Trigger client ID generation
        id(mqtt_client_id).set_password(x.c_str());

- platform: template
  name: "Username" #This name is the key for the rest api, do not change
  id: username_text
  mode: text
  restore_value: true
  optimistic: true
  state_topic:
  web_server:
    sorting_group_id: printago
    sorting_weight: 4
  icon: "mdi:account-circle"
  on_value:
    then:
    - lambda: |-
        ESP_LOGI("mqtt", "Username changed to: %s", x.c_str());
        // Trigger client ID generation
        id(mqtt_client_id_stored).update();

- platform: template
  id: printer_id_previous
  mode: text
  restore_value: false
  optimistic: true
  state_topic:
  internal: true

- platform: template
  name: "Printer ID" #This name is the key for the rest api, do not change
  id: printer_id
  mode: text
  restore_value: true
  optimistic: true
  state_topic:
  web_server:
    sorting_group_id: printago
    sorting_weight: 1
  on_value:
    then:
    - lambda: |-
        std::string previous_printer_id = id(printer_id_previous).state;
        std::string new_printer_id = x;

        ESP_LOGI("mqtt", "Printer ID changing from '%s' to '%s'", previous_printer_id.c_str(), new_printer_id.c_str());

        // Check if we should connect/reconnect to MQTT
        if (new_printer_id.empty() || id(username_text).state.empty() || id(mqtt_endpoint_text).state.empty() || id(mqtt_port_text).state.empty()) {
          ESP_LOGI("mqtt", "Username, printer ID, mqtt_endpoint or mqtt_port missing, disabling MQTT");
          id(clear_printago_status).execute();
          id(mqtt_client_id).disable();
          return;
        }

        ESP_LOGI("mqtt", "All required fields set, enabling MQTT");
        id(clear_printago_status).execute();
        id(check_printago_status).execute();
        id(mqtt_client_id).enable();

        // Unsubscribe from previous topics
        if (!previous_printer_id.empty() && !id(username_text).state.empty()) {
          std::string old_topic = "stores/" + id(username_text).state + "/printer-stats/" + previous_printer_id;
          std::string alt_old_topic = "stores/" + id(username_text).state + "/entities/printers/" + previous_printer_id;
          ESP_LOGI("mqtt", "Unsubscribing from previous topics");
          id(mqtt_client_id).unsubscribe(old_topic);
          id(mqtt_client_id).unsubscribe(alt_old_topic);
        }

        // Store the new value
        id(printer_id_previous).publish_state(new_printer_id);

        // Subscribe to printer stats topic
        std::string stats_topic = "stores/" + id(username_text).state + "/printer-stats/" + new_printer_id;
        ESP_LOGI("mqtt", "Subscribing to topic: %s", stats_topic.c_str());

        id(mqtt_client_id).subscribe_json(stats_topic, [](const std::string &topic, JsonObject root) {
          ESP_LOGV("mqtt", "Received JSON on stats topic");
          
          // Handle basic status - simple approach
          id(printer_is_online_sensor).publish_state(root.containsKey("isOnline") ? (bool)root["isOnline"] : false);
          id(printer_is_available_sensor).publish_state(root.containsKey("isAvailable") ? (bool)root["isAvailable"] : false);
          
          // Handle printer name
          if (root.containsKey("metadata")) {
            JsonObject metadata = root["metadata"];
            if (metadata.containsKey("name")) {
              const char* name = metadata["name"];
              if (name != nullptr) {
                id(printer_name).publish_state(name);
              }
            }
          }

          // Handle health status
          bool error_state = false;
          bool warning_state = false;
          if (root.containsKey("data")) {
            JsonObject data = root["data"];
            if (data.containsKey("health")) {
              JsonObject health = data["health"];
              if (health.containsKey("errors") && health["errors"].is<JsonArray>() && health["errors"].size() > 0) {
                error_state = true;
              }
              if (health.containsKey("warnings") && health["warnings"].is<JsonArray>() && health["warnings"].size() > 0) {
                warning_state = true;
              }
            }
          }
          id(printer_has_error_sensor).publish_state(error_state);
          id(printer_has_warning_sensor).publish_state(warning_state);

          // Handle downloading state
          bool download_state = false;
          if (root.containsKey("state")) {
            const char* state = root["state"];
            if (state != nullptr && strcmp(state, "PREPARE") == 0) {
              download_state = true;
            }
          }
          id(is_downloading).publish_state(download_state);
        });

        // Subscribe to entities topic for confirmedReady
        std::string entities_topic = "stores/" + id(username_text).state + "/entities/printers";
        ESP_LOGI("mqtt", "Subscribing to entities topic: %s", entities_topic.c_str());

        id(mqtt_client_id).subscribe_json(entities_topic, [new_printer_id](const std::string &topic, JsonObject root) {
          bool ready_state = false;
          if (root.containsKey("entities")) {
            JsonObject entities = root["entities"];
            if (entities.containsKey(new_printer_id.c_str())) {
              JsonObject printer_obj = entities[new_printer_id.c_str()];
              if (printer_obj.containsKey("confirmedReady")) {
                ready_state = (bool)printer_obj["confirmedReady"];
              }
            }
          }
          id(printer_confirmed_ready_sensor).publish_state(ready_state);
        });
button:
- platform: template
  name: "Check Printago Status"
  id: check_printago_status_button
  icon: "mdi:cloud-refresh"
  on_press:
  - script.execute: check_printago_status
  web_server:
    sorting_group_id: printago
    sorting_weight: 4

- platform: template
  name: "Fetch Printers"
  id: fetch_printago_printers_button
  icon: "mdi:printer-search"
  on_press:
  - script.execute: fetch_printago_printers
  web_server:
    sorting_group_id: printago
    sorting_weight: 5
